import sys
import random
from typing import List, Dict, Optional, Tuple

from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QLabel, QSpinBox, QPushButton,
    QVBoxLayout, QHBoxLayout, QFormLayout, QLineEdit, QGroupBox, QScrollArea,
    QMessageBox, QTableWidget, QTableWidgetItem, QSizePolicy
)


class SecretSantaWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Secret Santa – Couples Aware")
        self.resize(900, 700)

        # ===== Header with inputs =====
        header = QWidget()
        header_layout = QHBoxLayout(header)

        # Couples & singles inputs
        self.singles_spin = QSpinBox()
        self.singles_spin.setRange(0, 999)
        self.singles_spin.setValue(0)

        self.couples_spin = QSpinBox()
        self.couples_spin.setRange(0, 999)
        self.couples_spin.setValue(0)

        header_form = QFormLayout()
        header_form.setLabelAlignment(Qt.AlignRight)
        header_form.addRow(QLabel("Aantal aparte personen:"), self.singles_spin)
        header_form.addRow(QLabel("Aantal koppels:"), self.couples_spin)

        self.build_btn = QPushButton("Build list")
        self.build_btn.clicked.connect(self.build_name_fields)

        header_layout.addLayout(header_form, stretch=1)
        header_layout.addWidget(self.build_btn, stretch=0, alignment=Qt.AlignLeft)

        # ===== Names area (scrollable) =====
        self.names_area = QScrollArea()
        self.names_area.setWidgetResizable(True)
        self.names_container = QWidget()
        self.names_layout = QVBoxLayout(self.names_container)
        self.names_layout.setAlignment(Qt.AlignTop)
        self.names_area.setWidget(self.names_container)

        # ===== Action bar & results =====
        self.secret_btn = QPushButton("It's our little secret")
        self.secret_btn.setEnabled(False)
        self.secret_btn.clicked.connect(self.compute_secret_santa)

        self.results_table = QTableWidget(0, 2)
        self.results_table.setHorizontalHeaderLabels(["Giver", "Receiver"])
        self.results_table.horizontalHeader().setStretchLastSection(True)
        self.results_table.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        # ===== Main layout =====
        central = QWidget()
        central_layout = QVBoxLayout(central)
        central_layout.addWidget(header)
        central_layout.addWidget(self.names_area, stretch=1)
        central_layout.addWidget(self.secret_btn, alignment=Qt.AlignLeft)
        central_layout.addWidget(self.results_table, stretch=2)

        self.setCentralWidget(central)

        # Keep references to the line edits
        self.couple_edits: List[Tuple[QLineEdit, QLineEdit]] = []
        self.single_edits: List[QLineEdit] = []

    # ---------------- UI builders ----------------

    def clear_name_fields(self):
        # Remove all existing name widgets from the layout
        for i in reversed(range(self.names_layout.count())):
            item = self.names_layout.itemAt(i)
            w = item.widget()
            if w:
                w.setParent(None)
        self.couple_edits.clear()
        self.single_edits.clear()

    def build_name_fields(self):
        couples = self.couples_spin.value()
        singles = self.singles_spin.value()

        # Basic sanity checks
        total_people = 2 * couples + singles
        if total_people < 2:
            QMessageBox.warning(self, "Not enough people",
                                "Je hebt minstens 2 personen nodig.")
            self.secret_btn.setEnabled(False)
            return

        self.clear_name_fields()

        # Couples group
        couples_group = QGroupBox("Koppels")
        couples_layout = QVBoxLayout(couples_group)
        for i in range(1, couples + 1):
            row = QWidget()
            row_layout = QHBoxLayout(row)

            a = QLineEdit()
            b = QLineEdit()
            a.setPlaceholderText(f"Couple {i} – Persoon A")
            b.setPlaceholderText(f"Couple {i} – Persoon B")

            row_layout.addWidget(a)
            row_layout.addWidget(b)
            couples_layout.addWidget(row)
            self.couple_edits.append((a, b))

        # Singles group
        singles_group = QGroupBox("Aparte personen")
        singles_layout = QVBoxLayout(singles_group)
        for i in range(1, singles + 1):
            e = QLineEdit()
            e.setPlaceholderText(f"Single {i}")
            singles_layout.addWidget(e)
            self.single_edits.append(e)

        self.names_layout.addWidget(couples_group)
        self.names_layout.addWidget(singles_group)

        self.secret_btn.setEnabled(True)
        self.results_table.setRowCount(0)

    # ---------------- Core logic ----------------

    @staticmethod
    def _collect_participants(
        couple_edits: List[Tuple[QLineEdit, QLineEdit]],
        single_edits: List[QLineEdit]
    ) -> Tuple[List[str], Dict[str, Optional[str]]]:
        """
        Returns:
            people: list of all names (order matters for deterministic UI)
            partner_of: mapping name -> partner name (or None for singles)
        Raises:
            ValueError if any name missing or duplicates found.
        """
        people: List[str] = []
        partner_of: Dict[str, Optional[str]] = {}

        # Gather couples
        for (a_edit, b_edit) in couple_edits:
            a = a_edit.text().strip()
            b = b_edit.text().strip()
            if not a or not b:
                raise ValueError("Vul alle namen van koppels in (geen lege velden).")
            if a == b:
                raise ValueError("Namen binnen een koppel moeten verschillend zijn.")
            people.extend([a, b])
            partner_of[a] = b
            partner_of[b] = a

        # Gather singles
        for e in single_edits:
            s = e.text().strip()
            if not s:
                raise ValueError("Vul alle namen van aparte personen in (geen lege velden).")
            people.append(s)
            partner_of[s] = None

        # Check duplicates
        if len(set(people)) != len(people):
            raise ValueError("Elke naam moet uniek zijn (dubbele namen gevonden).")

        if len(people) < 2:
            raise ValueError("Je hebt minstens 2 personen nodig.")

        return people, partner_of

    @staticmethod
    def _find_assignment(
        people: List[str],
        partner_of: Dict[str, Optional[str]],
        max_tries: int = 200  # randomization seeds to avoid worst-case backtracking
    ) -> Optional[Dict[str, str]]:
        """
        Backtracking assignment that enforces:
          - no self assignment
          - no assignment to one's partner (if any)
        Returns mapping giver -> receiver or None if impossible.
        """
        n = len(people)
        # Quick impossibility check: if the only two participants are a couple
        if n == 2:
            a, b = people
            # The only possible pairing would be a<->b which is forbidden
            if partner_of.get(a) == b and partner_of.get(b) == a:
                return None

        # Precompute candidate lists for each giver
        base_candidates: Dict[str, List[str]] = {}
        for g in people:
            forbidden = {g}
            if partner_of.get(g):
                forbidden.add(partner_of[g])  # forbid partner if exists
            base_candidates[g] = [p for p in people if p not in forbidden]

        # Backtracking with a few randomizations to avoid dead-ends
        for _ in range(max_tries):
            receivers_available = set(people)
            assignment: Dict[str, str] = {}

            # Randomize order of givers (fail-fast: those with fewest options first)
            order = sorted(people, key=lambda x: len(base_candidates[x]))
            random.shuffle(order[:max(1, len(order)//3)])  # stir a bit

            def backtrack(idx: int) -> bool:
                if idx == len(order):
                    return True
                giver = order[idx]
                # Try candidates among still-available receivers
                candidates = [r for r in base_candidates[giver] if r in receivers_available]
                random.shuffle(candidates)
                for r in candidates:
                    assignment[giver] = r
                    receivers_available.remove(r)
                    if backtrack(idx + 1):
                        return True
                    # undo
                    receivers_available.add(r)
                    del assignment[giver]
                return False

            if backtrack(0):
                return assignment

        return None

    def compute_secret_santa(self):
        # Clear previous results
        self.results_table.setRowCount(0)

        try:
            people, partner_of = self._collect_participants(self.couple_edits, self.single_edits)
        except ValueError as e:
            QMessageBox.warning(self, "Ongeldige invoer", str(e))
            return

        assignment = self._find_assignment(people, partner_of)
        if assignment is None:
            QMessageBox.critical(
                self,
                "Geen geldige verdeling",
                "Er kon geen geldige Secret Santa-verdeling gevonden worden met de huidige namen.\n\n"
                "Tip: voeg extra personen toe of verander de samenstelling."
            )
            return

        # Fill results table
        self.results_table.setRowCount(len(assignment))
        for row, giver in enumerate(people):  # keep original order for display
            receiver = assignment[giver]
            self.results_table.setItem(row, 0, QTableWidgetItem(giver))
            self.results_table.setItem(row, 1, QTableWidgetItem(receiver))

        self.results_table.resizeColumnsToContents()
        self.results_table.horizontalHeader().setStretchLastSection(True)


def main():
    app = QApplication(sys.argv)
    win = SecretSantaWindow()
    win.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
